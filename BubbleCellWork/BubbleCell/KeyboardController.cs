using MonoTouch.Foundation;using MonoTouch.ObjCRuntime;using MonoTouch.UIKit;using System;using System.Drawing;using System.Collections.Generic;namespace BubbleCell{	internal class KeyboardController : NSObject	{		UIView mainView, rootView, messageBar;		UIScrollView scrollView;		NSObject willShowObserver, didShowObserver, hideObserver;		UIView keyboard = null;		UIPanGestureRecognizer keyboardPanRecognizer;		double oldUpDuration = 1;		UIViewAnimationCurve oldUpCurve = UIViewAnimationCurve.Linear;		public KeyboardController ( UIView mainView, UIView rootView, UIView messageBar, UIScrollView scrollView )		{			this.mainView = mainView;			this.rootView = rootView;			this.messageBar = messageBar;			this.scrollView = scrollView;			willShowObserver = UIKeyboard.Notifications.ObserveWillShow ( KeyboardWillShow );			hideObserver = UIKeyboard.Notifications.ObserveWillHide ( KeyboardWillHide );			didShowObserver = UIKeyboard.Notifications.ObserveDidShow ( KeyboardDidShow );		}		public void UnhookObservers ( )		{			willShowObserver.Dispose ( );			didShowObserver.Dispose ( );			hideObserver.Dispose ( );		}		void KeyboardWillShow ( object sender, UIKeyboardEventArgs e )		{			oldUpDuration = e.AnimationDuration;			oldUpCurve = e.AnimationCurve;			keyboardPanRecognizer = new UIPanGestureRecognizer ( PanGestureDidChange );			keyboardPanRecognizer.MinimumNumberOfTouches = 1;			keyboardPanRecognizer.WeakDelegate = this;			keyboardPanRecognizer.CancelsTouchesInView = false;			rootView.AddGestureRecognizer ( keyboardPanRecognizer );			if ( keyboard != null )			{				keyboard.Hidden = false;			}			UIView.Animate ( oldUpDuration, 0, oldUpCurve.ToUIViewAnimationOptions ( ), ( ) =>			{				var viewFrame = rootView.Frame;				var endRelative = rootView.ConvertRectFromView ( e.FrameEnd, null );				viewFrame.Height = endRelative.Y;				rootView.Frame = viewFrame;			}, ( ) =>			{			} );		}		void KeyboardWillHide ( object sender, UIKeyboardEventArgs e )		{			rootView.RemoveGestureRecognizer ( keyboardPanRecognizer );			keyboardPanRecognizer = null;		}		void KeyboardDidShow ( object sender, UIKeyboardEventArgs e )		{			UIWindow tempWindow = UIApplication.SharedApplication.Windows [1];			foreach ( UIView possibleKeyboard in tempWindow.Subviews )			{				if ( possibleKeyboard.Description.StartsWith ( @"<UIPeripheralHostView" ) )				{					keyboard = possibleKeyboard;					break;				}			}		}		void PanGestureDidChange ( UIPanGestureRecognizer gesture )		{			var touchPoint = gesture.LocationInView ( rootView );			if ( gesture.State == UIGestureRecognizerState.Changed )			{				// Dragging keyboard down				if ( touchPoint.Y > ToolbarTopWithKeyboard )				{					var diff = touchPoint.Y - messageBar.Frame.Y;					if ( messageBar.Frame.Top + diff > ToolbarTopWithNoKeyboard )						diff = ToolbarTopWithNoKeyboard - messageBar.Frame.Top;					var scrollPt = scrollView.ContentOffset;					var viewFrame = rootView.Frame;					viewFrame.Height += diff;					rootView.Frame = viewFrame;					scrollView.ContentOffset = scrollPt;					var keyFrame = keyboard.Frame;					keyFrame.Y += diff;					keyboard.Frame = keyFrame;				}				// Continue drag up 				else if ( messageBar.Frame.Y > ToolbarTopWithKeyboard )				{					var diff = ToolbarTopWithKeyboard - messageBar.Frame.Y;					var scrollPt = scrollView.ContentOffset;					var viewFrame = rootView.Frame;					viewFrame.Height += diff;					rootView.Frame = viewFrame;					scrollView.ContentOffset = scrollPt;					var keyFrame = keyboard.Frame;					keyFrame.Y += diff;					keyboard.Frame = keyFrame;				}			}			else if ( gesture.State == UIGestureRecognizerState.Ended )			{				// if the gesture ends more than 50 pts below its extended position 				// and it does not complete with an upward motion then dismiss the keyboard				if ( ( touchPoint.Y > ToolbarTopWithKeyboard + 50 ) && gesture.VelocityInView ( rootView ).Y > -100 )				{					var diff = ToolbarTopWithNoKeyboard - messageBar.Frame.Y;					if ( diff > 0 )					{						var currentDuration = oldUpDuration * ( ( diff ) / ( ToolbarTopWithNoKeyboard - ToolbarTopWithKeyboard ) );						UIView.Animate ( currentDuration, 0, oldUpCurve.ToUIViewAnimationOptions ( ), ( ) =>						{							var viewFrame = rootView.Frame;							viewFrame.Height += diff;							rootView.Frame = viewFrame;							var keyFrame = keyboard.Frame;							keyFrame.Y += diff;							keyboard.Frame = keyFrame;						}, ( ) =>						{							keyboard.Hidden = true;							messageBar.ResignFirstResponder ( );						} );					}					else					{						keyboard.Hidden = true;						messageBar.ResignFirstResponder ( );					}				}				// restore the keyboard to the extended position.				else				{					var diff = ToolbarTopWithKeyboard - messageBar.Frame.Y;					var currentDuration = oldUpDuration * ( ( -diff ) / ( ToolbarTopWithNoKeyboard - ToolbarTopWithKeyboard ) );					UIView.Animate ( currentDuration, 0, oldUpCurve.ToUIViewAnimationOptions ( ), ( ) =>					{						var viewFrame = rootView.Frame;						viewFrame.Height += diff;						rootView.Frame = viewFrame;						var keyFrame = keyboard.Frame;						keyFrame.Y += diff;						keyboard.Frame = keyFrame;					}, ( ) =>					{					} );				}			}		}		[Export ( "gestureRecognizer:shouldReceiveTouch:" )]		public virtual bool ShouldReceiveTouch ( UIGestureRecognizer recognizer, UITouch touch )		{			if ( recognizer == this.keyboardPanRecognizer )			{				// Don't allow panning if inside the active input (unless SELF is a UITextView and the receiving view)				return ( !touch.View.IsFirstResponder );			}			else			{				return true;			}		}		[Export ( "gestureRecognizer:shouldRecognizeSimultaneouslyWithGestureRecognizer:" )]		public virtual bool ShouldRecognizeSimultaneously ( UIGestureRecognizer gestureRecognizer, UIGestureRecognizer otherGestureRecognizer )		{			if ( gestureRecognizer == this.keyboardPanRecognizer || otherGestureRecognizer == this.keyboardPanRecognizer )			{				return true;			}			else			{				return false;			}		}		float ToolbarTopWithKeyboard		{			get			{				if ( keyboard != null )					return ToolbarTopWithNoKeyboard - keyboard.Frame.Height;				return ToolbarTopWithNoKeyboard - 100;			}		}		float ToolbarTopWithNoKeyboard		{			get			{				if ( messageBar != null )					return mainView.Frame.Height - ( messageBar.Frame.Height );				return mainView.Frame.Height - ( MessageBarView.EntryHeight );			}		}	}}